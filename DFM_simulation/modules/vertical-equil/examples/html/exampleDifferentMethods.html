
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>exampleDifferentMethods</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2012-12-19"><meta name="DC.source" content="exampleDifferentMethods.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">Vertical average formulations</a></li><li><a href="#3">Example to test vertical average caculation using different formulsation</a></li><li><a href="#4">Parameters for the simulation</a></li><li><a href="#5">Create the deck struct</a></li><li><a href="#6">Convert to SI</a></li><li><a href="#7">Instansiate grid and rock</a></li><li><a href="#8">Define wells, boundary conditions and source terms</a></li><li><a href="#9">Define system solvers</a></li><li><a href="#10">H formulation based solver</a></li><li><a href="#11">S formulation based solver</a></li><li><a href="#12">Initial solutions</a></li><li><a href="#13">Run the transport simulation.</a></li><li><a href="#14">Output calculation time</a></li><li><a href="#15">the state is now almost stationary we add the analytic calculation of the pressure</a></li></ul></div><pre class="codeinput"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</pre><h2>Vertical average formulations<a name="2"></a></h2><p>Here, we we study the use of different formultions for the vertical equlibrium approximations to the twophase flow in reservoirs.</p><pre>We start with the darcy laws verions of the darcy laws</pre><p><img src="exampleDifferentMethods_eq02627.png" alt="$$ v_{\alpha}= - \frac{1}{\mu} K kr_{\alpha}(s_{\alpha}) (\nabla p_{\alpha}&#xA;- \rho_{\alpha} \nabla z) \qquad \alpha=\{\mathrm{CO_2},\mathrm{water}\}$$"></p><p>The upscaled version of this using the assumption of vertical equlibrium sharp interface, constant permeability and porosity</p><p><img src="exampleDifferentMethods_eq85180.png" alt="$$ V_{\alpha}= - \frac{1}{\mu} K kr_{\alpha}(1) h&#xA;      (\nabla_{\parallel} P_{\alpha}- \rho_{\alpha} \nabla_{\parallel}&#xA;      z) \qquad \alpha=\{\mathrm{CO_2},\mathrm{water}\}$$"></p><p>Reformulated to using s as variable we can write</p><p><img src="exampleDifferentMethods_eq05616.png" alt="$$ V_{\alpha}= - \frac{1}{\mu} (HK) kr_{\alpha} s&#xA;      (\nabla_{\parallel} P_{\alpha}- \rho_{\alpha} \nabla_{\parallel}&#xA;      z)$$"></p><p>Ass usual the pressure equation fro incompressible flow is obtaind by <img src="exampleDifferentMethods_eq75146.png" alt="$$\nabla\cdot v = q, \qquad v=\sum_{\alpha} V_{\alpha},$">$</p><p>where v is the Darcy velocity (total velocity) and lambda_t is the total mobility, which depends on the water saturation S.</p><p>The transport equation (conservation of the CO2 phase) in its simplest form:</p><p><img src="exampleDifferentMethods_eq52776.png" alt="$$ \phi \frac{\partial S}{\partial t} +&#xA;    \nabla \cdot (f_w(S)(v + (K) \lambda_o (\nabla_{\parallel} (p_c + \rho z) )) = q_w$$"></p><pre>and</pre><p><img src="exampleDifferentMethods_eq46315.png" alt="$$ \phi \frac{\partial h}{\partial t} +&#xA;    \nabla \cdot (f_w(h (v + K \lambda_o (\nabla_{\parallel} (p_c + \rho z) )) = q_w$$"></p><h2>Example to test vertical average caculation using different formulsation<a name="3"></a></h2><p>The test case uses two wells at the start We compare to simulations</p><pre> 1) formulation using h as variable and mimetic for pressure and
    explicit time stepping. This was the original formulation in the
    vertical average module.</pre><pre> 2) Using s as variable and using tpfa an implicit transport from the
    mrst core.</pre><pre> The example also set up a compate deck file which can be written and
 may be used for simulation by tradition solvers</pre><pre class="codeinput"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
gravity <span class="string">on</span>
require <span class="string">deckformat</span> <span class="string">gridtools</span>
</pre><h2>Parameters for the simulation<a name="4"></a></h2><pre class="codeinput">n = 50;
L = 2000;
<span class="comment">% Cells in the vertical direction</span>
dim3 = 1;
<span class="comment">% Physical height of reservoir</span>
H = 15;
<span class="comment">% Physical idth of slice along the y axis</span>
dy = 1000;
<span class="comment">% Simulation time</span>
total_time = 100*year;
<span class="comment">% Timsteps</span>
nsteps = 20;
<span class="comment">% Uniform time stepping</span>
dt = total_time / nsteps;
<span class="comment">% Injection time</span>
injection_time=total_time/10;
perm = 100;
K = perm*milli*darcy();
phi = 0.1;

<span class="comment">% Initial depth</span>
depth = 1000;
<span class="comment">% Initial pressure</span>
p_press = 200;

rate=(H*phi*L*dy)*0.2*day/injection_time;


<span class="comment">% refine most near top in z</span>
theta = -1*pi/180;
</pre><h2>Create the deck struct<a name="5"></a></h2><pre class="codeinput">deck = sinusDeck([n 1 dim3], nsteps, dt, L, dy, H, theta, depth, phi, perm, rate, p_press);
</pre><h2>Convert to SI<a name="6"></a></h2><pre class="codeinput">deck = convertDeckUnits(deck);
</pre><h2>Instansiate grid and rock<a name="7"></a></h2><p>make grid</p><pre class="codeinput">G = initEclipseGrid(deck);
G = computeGeometry(G);

<span class="comment">% make top surface grid</span>
G_top = topSurfaceGrid(G);

G_top.cells.H = H*ones(G_top.cells.num,1);
G_top.columns.dz = ones(numel(G_top.columns.cells),1)*H/dim3;
G_top.columns.z = cumulativeHeight(G_top);

<span class="comment">% get permeability</span>
rock = initEclipseRock(deck);
rock2d  = averageRock(rock, G_top);

Gt_c = G_top.cells.centroids;
</pre><h2>Define wells, boundary conditions and source terms<a name="8"></a></h2><pre class="codeinput"><span class="comment">% Empty boundary conditions</span>
[bc_s, bc_h] = deal([]);

<span class="comment">% Empty sources</span>
[src_s, src_h] = deal([]);

<span class="keyword">for</span> i=1:numel(src_h)
    src_h.sat = nan;
    src_h.h = G_top.cells.H(src_s.cell);
<span class="keyword">end</span>


<span class="comment">% Create wells.</span>
<span class="comment">% Note that the deck is one cell thick to make indices which correspond to</span>
<span class="comment">% the top surface grid.</span>

<span class="comment">% Extract arbitrarily the first set of wells</span>
W_3D = processWells(G, rock, deck.SCHEDULE.control(1));
W_3D_2ph = W_3D;
<span class="comment">% change resv to rate which is used in the 2ph simulations</span>
<span class="keyword">for</span> i=1:numel(W_3D)
    <span class="keyword">if</span>(strcmp(W_3D(i).type,<span class="string">'resv'</span>))
        W_3D_2ph(i).type=<span class="string">'rate'</span>;
    <span class="keyword">end</span>
    <span class="comment">%  well indices is correct since they are calculated in 3D which</span>
    <span class="comment">% include the hight in the WI</span>
<span class="keyword">end</span>
<span class="comment">% Convert VE wells for s and h formulation</span>
<span class="comment">% We will use mimetic for the h formulation with ip_simple innerproduct</span>

W_h = convertwellsVE(W_3D_2ph, G, G_top, rock2d,<span class="string">'ip_simple'</span>);
<span class="comment">% We will use tpfa method for the s formulation</span>

W_s = convertwellsVE(W_3D_2ph, G, G_top, rock2d,<span class="string">'ip_tpf'</span>);
<span class="comment">% Correct the definition of input value according to solver. This is done</span>
<span class="comment">% because we are using the schedule primarily meant for black oil solvers</span>
<span class="comment">% with the VE two phase only solvers.</span>

<span class="keyword">for</span> i=1:numel(W_h)
    <span class="comment">% Inject CO2.</span>
    W_s(i).compi=[1 0];
    W_h(i).compi=nan;
    W_h(i).h = G_top.cells.H(W_h(i).cells);
<span class="keyword">end</span>
</pre><h2>Define system solvers<a name="9"></a></h2><pre class="codeinput"><span class="comment">% Create a cell array to hold helper variables and function handles for</span>
<span class="comment">% each solver.</span>

problem = cell(2,1);

mu = [deck.PROPS.PVDO{1}(1,3), deck.PROPS.PVTW(1,4)];
rho = deck.PROPS.DENSITY(1:2);
sr = 0.3;
sw = 0.3;
</pre><h2>H formulation based solver<a name="10"></a></h2><pre class="codeinput">tmp.fluid      = initVEFluidHForm(G_top, <span class="string">'mu'</span>, mu, <span class="keyword">...</span>
    <span class="string">'rho'</span>, rho,<span class="keyword">...</span>
    <span class="string">'sr'</span>,  sr, <span class="keyword">...</span>
    <span class="string">'sw'</span>,  sw);

<span class="comment">% Initial reservoir state</span>
tmp.sol        = initResSol(G_top, 0);

<span class="comment">% Precompute inner products</span>
S = computeMimeticIPVE(G_top,rock2d,<span class="string">'Innerproduct'</span>,<span class="string">'ip_simple'</span>);

<span class="comment">% Set up wells, boundary conditions and source terms</span>
tmp.W = W_h;
tmp.bc = bc_h;
tmp.src = src_h;

<span class="comment">% Define pressure solver with common interface</span>
tmp.psolver = @(sol,fluid,W,bc, src) solveIncompFlowVE(sol, G_top, S, rock2d, fluid, <span class="keyword">...</span>
    <span class="string">'wells'</span>, W, <span class="string">'bc'</span>, bc, <span class="string">'src'</span>, src);
<span class="comment">% Define a pressure solver</span>
tmp.tsolver =@(sol,fluid,dt,W,bc, src) explicitTransportVE(sol, G_top, dt, rock, fluid, <span class="keyword">...</span>
    <span class="string">'computeDt'</span>, true, <span class="string">'intVert_poro'</span>, false,<span class="string">'intVert'</span>,false,<span class="string">'wells'</span>,W,<span class="string">'bc'</span>,bc, <span class="string">'src'</span>, src);

<span class="comment">% As this solver solves for height of CO2 plume, it is not neccessary to</span>
<span class="comment">% compute h from saturation values.</span>
tmp.compute_h=false;

<span class="comment">% ...but we have to find the saturation.</span>
tmp.compute_sat=true;

<span class="comment">% Plot height in red.</span>
tmp.col=<span class="string">'r'</span>;

tmp.name = <span class="string">'H formulation using explicit transport and mimetic discretization'</span>;

<span class="comment">% We put the problems in a cell array to make the general structure for the</span>
<span class="comment">% different solvers obvious.</span>
problem{1} = tmp;

clear <span class="string">tmp</span>
</pre><h2>S formulation based solver<a name="11"></a></h2><pre class="codeinput">n=2;
tmp.fluid = initSimpleVEFluid_s(<span class="string">'mu'</span> ,      mu ,<span class="keyword">...</span>
    <span class="string">'rho'</span>, rho, <span class="keyword">...</span>
    <span class="string">'height'</span>  , G_top.cells.H,<span class="keyword">...</span>
    <span class="string">'sr'</span>, [sr, sw]);

tmp.sol        = initResSolVE_s(G_top, 0, [1 0]);
<span class="comment">% Notice the function handle</span>
tmp.sol.twophaseJacobian
<span class="comment">% Which points to the Jacobian System defining the VE formulation which is</span>
<span class="comment">% a slight extention of the origian Jacobian system twophaseJacobian used</span>
<span class="comment">% in MRST.</span>


<span class="comment">% TPFA solver, we need transmissibilities</span>
cellno = gridCellNo(G_top);

<span class="comment">% Calculate  Transmissibility for the 2D top surface grid.</span>
<span class="comment">% Depending on the definition of area and length in the topsurface grid</span>
<span class="comment">% this may or may not treat length along the surface.</span>
T = computeTrans(G_top,rock2d);
T = T.*G_top.cells.H(cellno);

tmp.bc = bc_s;
tmp.src = src_s;
<span class="comment">% Two point flux approximation as pressure solver</span>
tmp.psolver = @(sol,fluid, W, bc, src) incompTPFA(sol, G_top, T, fluid, <span class="keyword">...</span>
    <span class="string">'wells'</span>, W, <span class="string">'bc'</span>, bc, <span class="string">'src'</span>, src);
tmp.W = W_s;
<span class="comment">% Define implicit transport as the transport method</span>
tmp.tsolver = @(sol,fluid,dt,W,bc, src) implicitTransport(sol, G_top, dt, rock2d, fluid, <span class="keyword">...</span>
    <span class="string">'wells'</span>, W, <span class="string">'bc'</span>, bc, <span class="string">'src'</span>, src);

<span class="comment">% One need to calculate h separatly since the solver does not</span>
tmp.compute_h = true;
tmp.compute_sat = false;
tmp.col = <span class="string">'gs'</span>;

<span class="comment">% Note that the grid is modified with an extra field,</span>
G_top.grav_pressure
<span class="comment">% which defines a function handle to how to calculate the gravity</span>
<span class="comment">% contribution. This is the part which is VE spesific.</span>

tmp.name = <span class="string">'S formulation using implicit transport and two point flux'</span>;

problem{2} = tmp;

clear <span class="string">tmp</span>;
</pre><pre class="codeoutput">
ans = 

    @twophaseJacobianWithVE_s


ans = 

    @(g,omega)gravPressureVE_s(g,omega)

</pre><h2>Initial solutions<a name="12"></a></h2><pre class="codeinput"><span class="keyword">for</span> kk=1:numel(problem)
    s0 = deck.SOLUTION.SOIL;
    h0 = deck.SOLUTION.SOIL.*G_top.cells.H;
    problem{kk}.sol.s = s0;
    problem{kk}.sol.h = h0;
    problem{kk}.sol.extSat = [s0, s0];
    problem{kk}.sol.h_max = h0;

    <span class="comment">% Time pressure and transport solve</span>
    problem{kk}.p_time=0;
    problem{kk}.t_time=0;
<span class="keyword">end</span>
</pre><h2>Run the transport simulation.<a name="13"></a></h2><pre class="codeinput">fig1 = figure(1);
fig2 = figure(2);
fig3 = figure(3);
t = 0;
<span class="keyword">while</span> t &lt; total_time
    set(0, <span class="string">'CurrentFigure'</span>, fig1);clf
    set(0, <span class="string">'CurrentFigure'</span>, fig2);clf
    set(0, <span class="string">'CurrentFigure'</span>, fig3);clf
    set(gca,<span class="string">'YDir'</span>,<span class="string">'reverse'</span>)
    <span class="keyword">for</span> kk=1:numel(problem)
        tmp = problem{kk};

        free_volume = sum(tmp.sol.s.*rock2d.poro.*G_top.cells.volumes.*G_top.cells.H);
        disp([<span class="string">'Total volume free '</span>,num2str(kk),<span class="string">' '</span>, num2str(free_volume/1e6)]);

        <span class="keyword">if</span>(t&lt;injection_time)
            W = tmp.W;
            bc = tmp.bc;
            src = tmp.src;
        <span class="keyword">else</span>
            W = [];
            bc = [];
            src = [];
        <span class="keyword">end</span>

        <span class="comment">% Solve the pressure</span>
        timer = tic;
        tmp.sol = tmp.psolver(tmp.sol, tmp.fluid,  W, bc, src);
        tmp.p_time = tmp.p_time + toc(timer);

        <span class="comment">% Using the computed fluxes, solve the transport</span>
        timer = tic;
        nn=1;
        <span class="keyword">for</span> ii=1:nn
            <span class="keyword">if</span>(t&gt;injection_time)
                <span class="comment">% uncomment to forcing zero total flow</span>
                <span class="comment">%tmp.sol.flux(:) = 0;</span>
            <span class="keyword">end</span>
            tmp.sol = tmp.tsolver(tmp.sol,tmp.fluid,dt/nn,W,bc, src);
        <span class="keyword">end</span>

        tmp.t_time =tmp.t_time + toc(timer );

        <span class="keyword">if</span>(tmp.compute_h)
            <span class="comment">% Compute h if this problem needs it</span>
            [h, h_max]    = tmp.fluid.sat2height(tmp.sol);
            tmp.sol.h     = h;
            tmp.sol.h_max = h_max;

            <span class="comment">% set the value s_max for convenience</span>
            tmp.sol.s_max = tmp.sol.extSat(:,2);
        <span class="keyword">end</span>
        <span class="keyword">if</span>(tmp.compute_sat)
            <span class="comment">% if the solver do not compute s, s_max calculate it</span>
            tmp.sol.s =  (tmp.sol.h*(1-sw) + (tmp.sol.h_max - tmp.sol.h)*sr)./G_top.cells.H;
            tmp.sol.s_max =  tmp.sol.h_max*(1 - sw)./G_top.cells.H;
        <span class="keyword">end</span>

        <span class="keyword">if</span>(G_top.cartDims(2)==1)
            <span class="comment">% plot saturation and max_h</span>
            set(0, <span class="string">'CurrentFigure'</span>, fig1);

            subplot(2, 2, 1)
            hold <span class="string">on</span>
            plot(Gt_c(:,1), tmp.sol.h, tmp.col)

            <span class="comment">% Freeze axes</span>
            <span class="keyword">if</span>(kk==1);
                axh=axis();
            <span class="keyword">else</span>
                axis(axh);
            <span class="keyword">end</span>

            ylim([0 H])
            title(<span class="string">'Height'</span>);
            xlabel(<span class="string">'x'</span>);
            ylabel(<span class="string">'h'</span>);

            subplot(2, 2, 2)
            hold <span class="string">on</span>
            plot(Gt_c(:,1), tmp.sol.h_max,tmp.col)

            <span class="keyword">if</span>(kk==1);
                axh_max=axis();
            <span class="keyword">else</span>
                axis(axh_max);
            <span class="keyword">end</span>

            ylim([0 H])
            title(<span class="string">'Max Height'</span>);
            xlabel(<span class="string">'x'</span>);
            ylabel(<span class="string">'h_max'</span>) ;

            subplot(2, 2, 3)
            hold <span class="string">on</span>
            plot(Gt_c(:,1), tmp.sol.s(:,1),tmp.col)

            <span class="keyword">if</span>(kk==1);
                axs=axis();
            <span class="keyword">else</span>
                axis(axs);
            <span class="keyword">end</span>

            ylim([0 1])
            title(<span class="string">'Saturation'</span>);
            xlabel(<span class="string">'x'</span>);
            ylabel(<span class="string">'s'</span>)

            subplot(2, 2, 4)
            hold <span class="string">on</span>
            plot(Gt_c(:,1), tmp.sol.s_max(:,1), tmp.col)

            <span class="keyword">if</span>(kk==1);
                axs_max=axis();
            <span class="keyword">else</span>
                axis(axs_max);
            <span class="keyword">end</span>

            ylim([0 1])
            title(<span class="string">'Max Saturation'</span>);
            xlabel(<span class="string">'x'</span>);
            ylabel(<span class="string">'s_max'</span>)


            set(0, <span class="string">'CurrentFigure'</span>, fig2);
            hold <span class="string">on</span>
            plot(Gt_c(:,1),tmp.sol.pressure/barsa,tmp.col)
            <span class="keyword">if</span>(~tmp.compute_sat)
                <span class="comment">% Also plot CO2 pressure: The default is to use the pressure of</span>
                <span class="comment">% the second phase pressure for the incompressible solvers</span>
                plot(Gt_c(:,1),(tmp.sol.pressure-tmp.fluid.pc(tmp.sol)),[<span class="string">'-'</span>,tmp.col])
            <span class="keyword">else</span>
                plot(Gt_c(:,1),(tmp.sol.pressure-norm(gravity)*rho(1)*tmp.sol.h),[<span class="string">'s'</span>,tmp.col])
            <span class="keyword">end</span>
            xlabel(<span class="string">'x'</span>)
            ylabel(<span class="string">'pressure'</span>)
            title(<span class="string">'Comparing pressure for the different solvers'</span>)

            <span class="comment">%   1) for the injection period the well indexs which is not exact</span>
            <span class="comment">%      for a 1D calculation effect the result.</span>

            set(0, <span class="string">'CurrentFigure'</span>, fig3);
            hold <span class="string">on</span>
            <span class="keyword">if</span>(kk==1)
                z = G_top.cells.z;
                plot(Gt_c(:,1),z,<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,2)
                plot(Gt_c(:,1),z+G_top.cells.H,<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,2)
                mind = floor(G_top.cells.num/2);
                text(Gt_c(mind,1), z(mind) - 5,<span class="string">'Top surface'</span>)
                text(Gt_c(mind,1), z(mind) + G_top.cells.H(mind)+5,<span class="string">'Bottom surface'</span>)
                mind = floor(G_top.cells.num/4);
                text(Gt_c(mind,1)-50, z(mind)+tmp.sol.h(mind)-2,<span class="string">'Free CO2'</span>,<span class="string">'Color'</span>,<span class="string">'b'</span>)
                text(Gt_c(mind,1), z(mind)+tmp.sol.h_max(mind)+1,<span class="string">'Max CO2'</span>,<span class="string">'Color'</span>,<span class="string">'r'</span>)
            <span class="keyword">end</span>
            plot(Gt_c(:,1),G_top.cells.z+tmp.sol.h,<span class="string">'b'</span>)
            plot(Gt_c(:,1),G_top.cells.z+tmp.sol.h_max,<span class="string">'r'</span>)
            box <span class="string">on</span>;axis <span class="string">tight</span>

            title(<span class="string">'Surfaces'</span>)
            xlabel(<span class="string">'x'</span>)
            ylabel(<span class="string">'depth'</span>)


        <span class="keyword">else</span>
            subplot(numel(problem),2,(2*(kk-1))+1)
            pcolor(X,Y,reshape(tmp.sol.h,G_top.cartDims))
            <span class="keyword">if</span>(kk==1)
                cxs=caxis();
            <span class="keyword">else</span>
                caxis(cxs);
            <span class="keyword">end</span>;
            title([<span class="string">'Height '</span>,num2str(kk)]);colorbar,shading <span class="string">interp</span>
            subplot(numel(problem),2,(2*(kk-1))+2)
            pcolor(X,Y,reshape(tmp.sol.max_h,G_top.cartDims))
            caxis(cxs)
            title([<span class="string">'Max Height'</span>,num2str(kk)]);colorbar,shading <span class="string">interp</span>
        <span class="keyword">end</span>
        problem{kk} = tmp;
    <span class="keyword">end</span>
    set(0, <span class="string">'CurrentFigure'</span>, fig1);
    drawnow;
    set(0, <span class="string">'CurrentFigure'</span>, fig2);
    drawnow;
    set(0, <span class="string">'CurrentFigure'</span>, fig3);

    drawnow;
    t=t+dt;
<span class="keyword">end</span>
</pre><pre class="codeoutput">Total volume free 1 0
Total volume free 2 0
Total volume free 1 0.29943
Total volume free 2 0.28899
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
Total volume free 1 0.53699
Total volume free 2 0.50501
</pre><img vspace="5" hspace="5" src="exampleDifferentMethods_01.png" alt=""> <img vspace="5" hspace="5" src="exampleDifferentMethods_02.png" alt=""> <img vspace="5" hspace="5" src="exampleDifferentMethods_03.png" alt=""> <h2>Output calculation time<a name="14"></a></h2><pre class="codeinput"><span class="keyword">for</span> kk = 1:numel(problem)
   fprintf(<span class="string">'Time used for solving with %s\n'</span>,problem{kk}.name);
   fprintf(<span class="string">'\t Pressure time : %2.2d sec\n'</span> ,problem{kk}.p_time)
   fprintf(<span class="string">'\t Transport time : %2.2s sec\n'</span>,problem{kk}.t_time)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Time used for solving with H formulation using explicit transport and mimetic discretization
	 Pressure time : 9.87e-02 sec
	 Transport time : 7.98e-01 sec
Time used for solving with S formulation using implicit transport and two point flux
	 Pressure time : 8.33e-02 sec
	 Transport time : 1.32e+01 sec
</pre><h2>the state is now almost stationary we add the analytic calculation of the pressure<a name="15"></a></h2><p>set(0, 'CurrentFigure', fig2);</p><pre class="codeinput">clf
hold <span class="string">on</span>
<span class="comment">%In this example it is always only water at the bottom</span>
<span class="comment">%for hydrostatic conditions we can find the pressure at the</span>
<span class="comment">%bottom assuming zero pressure at the top of the first column</span>

p = tmp.sol.pressure(1);

sol_h = problem{1}.sol;
sol_s = problem{2}.sol;

rwg = rho(2)*norm(gravity);
z = G_top.cells.z;
H = G_top.cells.H;

plot(Gt_c(:,1),rwg*(z+H(1)-z(1))+p,<span class="string">'dk-'</span>)
<span class="comment">% water pressure extrapolated hydrostatic to top of reservoir</span>
plot(Gt_c(:,1), rwg*(z - z(1)) + p,<span class="string">'dk-'</span>)
<span class="comment">% water pressure at interface of co2 and water</span>
plot(Gt_c(:,1), rwg*(z + sol_h.h - z(1)) + p,<span class="string">'dk-'</span>)

<span class="comment">% CO2 at the top surface</span>
plot(Gt_c(:,1),<span class="keyword">...</span>
    rwg*(z+H(1) -(z(1))) + p - norm(gravity)*(rho(2)*(H - sol_s.h) + rho(1)*sol_s.h),<span class="string">'dr-'</span>)

text(600,1*barsa,<span class="string">'Water pressure at bottom'</span>)
text(600,-3.5*barsa,<span class="string">'Water extrapolated to top'</span>)
text(1300,-2*barsa,<span class="string">'Pressure at interface'</span>)
text(1850,-3*barsa,<span class="string">'Pressure at top'</span>)
set(gca, <span class="string">'YDir'</span>, <span class="string">'reverse'</span>)
<span class="comment">% In this plot of the pressure at the end we see</span>
<span class="comment">%    - The mimetic calculate the pressure at the interface between</span>
<span class="comment">%        co2 and water</span>
<span class="comment">%      - The tpfa with the given fluid calculate the extrapolated</span>
<span class="comment">%        water pressure at the top</span>
</pre><img vspace="5" hspace="5" src="exampleDifferentMethods_04.png" alt=""> <p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Vertical average formulations 
% Here, we we study the use of different formultions for the vertical
% equlibrium approximations to the twophase flow in reservoirs. 
%  
%  We start with the darcy laws verions of the darcy laws
%
% $$ v_{\alpha}= - \frac{1}{\mu} K kr_{\alpha}(s_{\alpha}) (\nabla p_{\alpha}
% - \rho_{\alpha} \nabla z) \qquad \alpha=\{\mathrm{CO_2},\mathrm{water}\}$$  
%
% The upscaled version of this using the assumption of vertical equlibrium 
% sharp interface, constant permeability and porosity
% 
% $$ V_{\alpha}= - \frac{1}{\mu} K kr_{\alpha}(1) h 
%       (\nabla_{\parallel} P_{\alpha}- \rho_{\alpha} \nabla_{\parallel}
%       z) \qquad \alpha=\{\mathrm{CO_2},\mathrm{water}\}$$
% 
% 
% Reformulated to using s as variable we can write 
% 
% $$ V_{\alpha}= - \frac{1}{\mu} (HK) kr_{\alpha} s 
%       (\nabla_{\parallel} P_{\alpha}- \rho_{\alpha} \nabla_{\parallel}
%       z)$$
%
% Ass usual the pressure equation fro incompressible flow is obtaind by
% $$\nabla\cdot v = q, \qquad v=\sum_{\alpha} V_{\alpha},$$
%
% where v is the Darcy velocity (total velocity) and lambda_t is the
% total mobility, which depends on the water saturation S.
%
% The transport equation (conservation of the CO2 phase) in its simplest form:
%
% $$ \phi \frac{\partial S}{\partial t} +
%     \nabla \cdot (f_w(S)(v + (K) \lambda_o (\nabla_{\parallel} (p_c + \rho z) )) = q_w$$
%
%  and 
%
% $$ \phi \frac{\partial h}{\partial t} +
%     \nabla \cdot (f_w(h (v + K \lambda_o (\nabla_{\parallel} (p_c + \rho z) )) = q_w$$
%
%
%% Example to test vertical average caculation using different formulsation
% The test case uses two wells at the start
% We compare to simulations
%
%   1) formulation using h as variable and mimetic for pressure and
%      explicit time stepping. This was the original formulation in the
%      vertical average module.
%
%   2) Using s as variable and using tpfa an implicit transport from the
%      mrst core. 
%
%   The example also set up a compate deck file which can be written and
%   may be used for simulation by tradition solvers
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
gravity on
require deckformat gridtools

%% Parameters for the simulation
n = 50; 
L = 2000;
% Cells in the vertical direction
dim3 = 1; 
% Physical height of reservoir
H = 15; 
% Physical idth of slice along the y axis
dy = 1000;
% Simulation time 
total_time = 100*year;
% Timsteps 
nsteps = 20;
% Uniform time stepping
dt = total_time / nsteps;
% Injection time
injection_time=total_time/10;
perm = 100;
K = perm*milli*darcy();
phi = 0.1;

% Initial depth
depth = 1000; 
% Initial pressure
p_press = 200; 

rate=(H*phi*L*dy)*0.2*day/injection_time;


% refine most near top in z
theta = -1*pi/180;


%% Create the deck struct
deck = sinusDeck([n 1 dim3], nsteps, dt, L, dy, H, theta, depth, phi, perm, rate, p_press);

%% Convert to SI
deck = convertDeckUnits(deck);

%% Instansiate grid and rock
% make grid
G = initEclipseGrid(deck);
G = computeGeometry(G);

% make top surface grid
G_top = topSurfaceGrid(G);

G_top.cells.H = H*ones(G_top.cells.num,1);
G_top.columns.dz = ones(numel(G_top.columns.cells),1)*H/dim3;
G_top.columns.z = cumulativeHeight(G_top);

% get permeability
rock = initEclipseRock(deck);
rock2d  = averageRock(rock, G_top);

Gt_c = G_top.cells.centroids;


%% Define wells, boundary conditions and source terms

% Empty boundary conditions
[bc_s, bc_h] = deal([]);

% Empty sources
[src_s, src_h] = deal([]);

for i=1:numel(src_h)
    src_h.sat = nan;
    src_h.h = G_top.cells.H(src_s.cell);
end


% Create wells.
% Note that the deck is one cell thick to make indices which correspond to
% the top surface grid.

% Extract arbitrarily the first set of wells
W_3D = processWells(G, rock, deck.SCHEDULE.control(1));
W_3D_2ph = W_3D;
% change resv to rate which is used in the 2ph simulations
for i=1:numel(W_3D)
    if(strcmp(W_3D(i).type,'resv'))
        W_3D_2ph(i).type='rate';
    end
    %  well indices is correct since they are calculated in 3D which
    % include the hight in the WI
end
% Convert VE wells for s and h formulation
% We will use mimetic for the h formulation with ip_simple innerproduct

W_h = convertwellsVE(W_3D_2ph, G, G_top, rock2d,'ip_simple');
% We will use tpfa method for the s formulation

W_s = convertwellsVE(W_3D_2ph, G, G_top, rock2d,'ip_tpf');
% Correct the definition of input value according to solver. This is done
% because we are using the schedule primarily meant for black oil solvers
% with the VE two phase only solvers.

for i=1:numel(W_h)
    % Inject CO2.
    W_s(i).compi=[1 0];
    W_h(i).compi=nan;
    W_h(i).h = G_top.cells.H(W_h(i).cells);
end


%% Define system solvers

% Create a cell array to hold helper variables and function handles for
% each solver.

problem = cell(2,1);

mu = [deck.PROPS.PVDO{1}(1,3), deck.PROPS.PVTW(1,4)];
rho = deck.PROPS.DENSITY(1:2);
sr = 0.3;
sw = 0.3;

%% H formulation based solver
tmp.fluid      = initVEFluidHForm(G_top, 'mu', mu, ...
    'rho', rho,...
    'sr',  sr, ...
    'sw',  sw);

% Initial reservoir state
tmp.sol        = initResSol(G_top, 0);

% Precompute inner products
S = computeMimeticIPVE(G_top,rock2d,'Innerproduct','ip_simple');

% Set up wells, boundary conditions and source terms
tmp.W = W_h;
tmp.bc = bc_h;
tmp.src = src_h;

% Define pressure solver with common interface
tmp.psolver = @(sol,fluid,W,bc, src) solveIncompFlowVE(sol, G_top, S, rock2d, fluid, ...
    'wells', W, 'bc', bc, 'src', src);
% Define a pressure solver
tmp.tsolver =@(sol,fluid,dt,W,bc, src) explicitTransportVE(sol, G_top, dt, rock, fluid, ...
    'computeDt', true, 'intVert_poro', false,'intVert',false,'wells',W,'bc',bc, 'src', src);

% As this solver solves for height of CO2 plume, it is not neccessary to
% compute h from saturation values.
tmp.compute_h=false;

% ...but we have to find the saturation.
tmp.compute_sat=true;

% Plot height in red.
tmp.col='r';

tmp.name = 'H formulation using explicit transport and mimetic discretization';

% We put the problems in a cell array to make the general structure for the
% different solvers obvious.
problem{1} = tmp;

clear tmp
%% S formulation based solver
n=2;
tmp.fluid = initSimpleVEFluid_s('mu' ,      mu ,...
    'rho', rho, ...
    'height'  , G_top.cells.H,...
    'sr', [sr, sw]);

tmp.sol        = initResSolVE_s(G_top, 0, [1 0]);
% Notice the function handle 
tmp.sol.twophaseJacobian
% Which points to the Jacobian System defining the VE formulation which is
% a slight extention of the origian Jacobian system twophaseJacobian used
% in MRST.


% TPFA solver, we need transmissibilities
cellno = gridCellNo(G_top);

% Calculate  Transmissibility for the 2D top surface grid.
% Depending on the definition of area and length in the topsurface grid
% this may or may not treat length along the surface.
T = computeTrans(G_top,rock2d);
T = T.*G_top.cells.H(cellno);

tmp.bc = bc_s;
tmp.src = src_s;
% Two point flux approximation as pressure solver
tmp.psolver = @(sol,fluid, W, bc, src) incompTPFA(sol, G_top, T, fluid, ...
    'wells', W, 'bc', bc, 'src', src);
tmp.W = W_s;
% Define implicit transport as the transport method
tmp.tsolver = @(sol,fluid,dt,W,bc, src) implicitTransport(sol, G_top, dt, rock2d, fluid, ...
    'wells', W, 'bc', bc, 'src', src);

% One need to calculate h separatly since the solver does not
tmp.compute_h = true;
tmp.compute_sat = false;
tmp.col = 'gs';

% Note that the grid is modified with an extra field,
G_top.grav_pressure
% which defines a function handle to how to calculate the gravity
% contribution. This is the part which is VE spesific. 

tmp.name = 'S formulation using implicit transport and two point flux';

problem{2} = tmp;

clear tmp;

%% Initial solutions

for kk=1:numel(problem)
    s0 = deck.SOLUTION.SOIL;
    h0 = deck.SOLUTION.SOIL.*G_top.cells.H;
    problem{kk}.sol.s = s0;
    problem{kk}.sol.h = h0;
    problem{kk}.sol.extSat = [s0, s0];
    problem{kk}.sol.h_max = h0;
    
    % Time pressure and transport solve
    problem{kk}.p_time=0;
    problem{kk}.t_time=0;
end

%% Run the transport simulation.
fig1 = figure(1);
fig2 = figure(2);
fig3 = figure(3);
t = 0;
while t < total_time
    set(0, 'CurrentFigure', fig1);clf
    set(0, 'CurrentFigure', fig2);clf
    set(0, 'CurrentFigure', fig3);clf
    set(gca,'YDir','reverse')
    for kk=1:numel(problem)
        tmp = problem{kk};
        
        free_volume = sum(tmp.sol.s.*rock2d.poro.*G_top.cells.volumes.*G_top.cells.H);
        disp(['Total volume free ',num2str(kk),' ', num2str(free_volume/1e6)]);
        
        if(t<injection_time)
            W = tmp.W;
            bc = tmp.bc;
            src = tmp.src;
        else
            W = [];
            bc = [];
            src = [];
        end
        
        % Solve the pressure
        timer = tic;
        tmp.sol = tmp.psolver(tmp.sol, tmp.fluid,  W, bc, src);
        tmp.p_time = tmp.p_time + toc(timer);
        
        % Using the computed fluxes, solve the transport
        timer = tic;
        nn=1;
        for ii=1:nn
            if(t>injection_time)
                % uncomment to forcing zero total flow
                %tmp.sol.flux(:) = 0;
            end
            tmp.sol = tmp.tsolver(tmp.sol,tmp.fluid,dt/nn,W,bc, src);
        end
        
        tmp.t_time =tmp.t_time + toc(timer );
        
        if(tmp.compute_h)
            % Compute h if this problem needs it
            [h, h_max]    = tmp.fluid.sat2height(tmp.sol);
            tmp.sol.h     = h;
            tmp.sol.h_max = h_max;
            
            % set the value s_max for convenience
            tmp.sol.s_max = tmp.sol.extSat(:,2);
        end
        if(tmp.compute_sat)
            % if the solver do not compute s, s_max calculate it
            tmp.sol.s =  (tmp.sol.h*(1-sw) + (tmp.sol.h_max - tmp.sol.h)*sr)./G_top.cells.H;
            tmp.sol.s_max =  tmp.sol.h_max*(1 - sw)./G_top.cells.H;
        end
        
        if(G_top.cartDims(2)==1)
            % plot saturation and max_h
            set(0, 'CurrentFigure', fig1);
            
            subplot(2, 2, 1)
            hold on
            plot(Gt_c(:,1), tmp.sol.h, tmp.col)
            
            % Freeze axes
            if(kk==1);
                axh=axis();
            else
                axis(axh);
            end
            
            ylim([0 H])
            title('Height');
            xlabel('x');
            ylabel('h');
            
            subplot(2, 2, 2)
            hold on
            plot(Gt_c(:,1), tmp.sol.h_max,tmp.col)
            
            if(kk==1);
                axh_max=axis();
            else
                axis(axh_max);
            end
            
            ylim([0 H])
            title('Max Height');
            xlabel('x'); 
            ylabel('h_max') ;
            
            subplot(2, 2, 3)
            hold on
            plot(Gt_c(:,1), tmp.sol.s(:,1),tmp.col)
            
            if(kk==1);
                axs=axis();
            else
                axis(axs);
            end
            
            ylim([0 1])
            title('Saturation');
            xlabel('x');
            ylabel('s')
            
            subplot(2, 2, 4)
            hold on
            plot(Gt_c(:,1), tmp.sol.s_max(:,1), tmp.col)
            
            if(kk==1);
                axs_max=axis();
            else
                axis(axs_max);
            end
            
            ylim([0 1])
            title('Max Saturation');
            xlabel('x'); 
            ylabel('s_max')
            
            
            set(0, 'CurrentFigure', fig2);
            hold on
            plot(Gt_c(:,1),tmp.sol.pressure/barsa,tmp.col)
            if(~tmp.compute_sat)
                % Also plot CO2 pressure: The default is to use the pressure of
                % the second phase pressure for the incompressible solvers
                plot(Gt_c(:,1),(tmp.sol.pressure-tmp.fluid.pc(tmp.sol)),['-',tmp.col])
            else
                plot(Gt_c(:,1),(tmp.sol.pressure-norm(gravity)*rho(1)*tmp.sol.h),['s',tmp.col])
            end
            xlabel('x')
            ylabel('pressure')
            title('Comparing pressure for the different solvers')
            
            %   1) for the injection period the well indexs which is not exact
            %      for a 1D calculation effect the result.
            
            set(0, 'CurrentFigure', fig3);
            hold on
            if(kk==1)
                z = G_top.cells.z;
                plot(Gt_c(:,1),z,'k','LineWidth',2)
                plot(Gt_c(:,1),z+G_top.cells.H,'k','LineWidth',2)
                mind = floor(G_top.cells.num/2);
                text(Gt_c(mind,1), z(mind) - 5,'Top surface')
                text(Gt_c(mind,1), z(mind) + G_top.cells.H(mind)+5,'Bottom surface')
                mind = floor(G_top.cells.num/4);
                text(Gt_c(mind,1)-50, z(mind)+tmp.sol.h(mind)-2,'Free CO2','Color','b')
                text(Gt_c(mind,1), z(mind)+tmp.sol.h_max(mind)+1,'Max CO2','Color','r')
            end
            plot(Gt_c(:,1),G_top.cells.z+tmp.sol.h,'b')
            plot(Gt_c(:,1),G_top.cells.z+tmp.sol.h_max,'r')
            box on;axis tight
            
            title('Surfaces')
            xlabel('x')
            ylabel('depth')
            
            
        else
            subplot(numel(problem),2,(2*(kk-1))+1)
            pcolor(X,Y,reshape(tmp.sol.h,G_top.cartDims))
            if(kk==1)
                cxs=caxis();
            else
                caxis(cxs);
            end;
            title(['Height ',num2str(kk)]);colorbar,shading interp
            subplot(numel(problem),2,(2*(kk-1))+2)
            pcolor(X,Y,reshape(tmp.sol.max_h,G_top.cartDims))
            caxis(cxs)
            title(['Max Height',num2str(kk)]);colorbar,shading interp
        end
        problem{kk} = tmp;
    end
    set(0, 'CurrentFigure', fig1);
    drawnow;
    set(0, 'CurrentFigure', fig2);
    drawnow;
    set(0, 'CurrentFigure', fig3);
    
    drawnow;
    t=t+dt;
end
%% Output calculation time
for kk = 1:numel(problem)
   fprintf('Time used for solving with %s\n',problem{kk}.name);
   fprintf('\t Pressure time : %2.2d sec\n' ,problem{kk}.p_time)
   fprintf('\t Transport time : %2.2s sec\n',problem{kk}.t_time)
end

%% the state is now almost stationary we add the analytic calculation of the pressure
% set(0, 'CurrentFigure', fig2);
clf
hold on
%In this example it is always only water at the bottom
%for hydrostatic conditions we can find the pressure at the
%bottom assuming zero pressure at the top of the first column

p = tmp.sol.pressure(1);

sol_h = problem{1}.sol;
sol_s = problem{2}.sol;

rwg = rho(2)*norm(gravity);
z = G_top.cells.z;
H = G_top.cells.H;

plot(Gt_c(:,1),rwg*(z+H(1)-z(1))+p,'dk-')
% water pressure extrapolated hydrostatic to top of reservoir
plot(Gt_c(:,1), rwg*(z - z(1)) + p,'dk-')
% water pressure at interface of co2 and water
plot(Gt_c(:,1), rwg*(z + sol_h.h - z(1)) + p,'dk-')

% CO2 at the top surface
plot(Gt_c(:,1),...
    rwg*(z+H(1) -(z(1))) + p - norm(gravity)*(rho(2)*(H - sol_s.h) + rho(1)*sol_s.h),'dr-')

text(600,1*barsa,'Water pressure at bottom')
text(600,-3.5*barsa,'Water extrapolated to top')
text(1300,-2*barsa,'Pressure at interface')
text(1850,-3*barsa,'Pressure at top')
set(gca, 'YDir', 'reverse')
% In this plot of the pressure at the end we see
%    - The mimetic calculate the pressure at the interface between
%        co2 and water
%      - The tpfa with the given fluid calculate the extrapolated
%        water pressure at the top


##### SOURCE END #####
--></body></html>